# 大纲

用类似于 nestjs 的思路，去实现一个带状态的多线程游戏框架。不同的是，这个框架用网关+多实体的方案。

## 参考

- [NESTJS 微服务 - Mr_Kahn - 博客园 (cnblogs.com)](https://www.cnblogs.com/Mr-Kahn/p/15129631.html)

## 架构

- core：核心实现，解决两个问题
  - driver：解决外部通讯问题，例如监听端口，常见的 httpserver/socket.io，如果是多端口会负载均衡到多个线程
  - 实体调度：解决内部实体的通讯问题
- controller：前端实体，每个 driver 实例都会绑定一个，用于解决 driver 的业务问题，为了性能考虑，设计上会让它和 driver 相同线程。
- service：后端实体，用于业务逻辑的负载均衡。

## 实体

实体是一个拥有地址，提供业务逻辑的基础单位。可以理解为是其他角色的基类。实体之间可以通过路由发送信息。

- 角色：每个实体都必然有自己的角色，不同角色提供不同的业务逻辑
- 地址：用于实体之间的直接通讯
- 名称：可选
- 线程：每个实体，都会从属于某个线程，在实体创建的时候，通过某个规则调度到线程中去

### 实体：创建

```typescript
function create(target: string | object, inputs?: Array): number;
```

- target: 指代要发送到的对象
  - string：创建一个实体，同时在全局命名服务中注册进去，之后通过名称就可以检索到这个对象的地址
  - object:
    - object.name：角色名称
    - object.id：角色的 id，这个实体，会被分派到这个 id%threads 的线程中
    - object.thread：指定的线程，和 object.id 冲突
- inputs: 传递给实体的构造函数的参数
- returns：返回实体地址

### 实体：远程调用

```typescript
function send(
  target: string | object,
  name: string,
  inputs?: Array,
  options?: object
);
function call(
  target: string | object,
  name: string,
  inputs?: Array,
  options?: object
);
```

- target:要发送到的对象
- name: 要远程调用的函数名称
- inputs: 传递给远程调用的参数

### 实体：销毁

```typescript
function destroy(target: string | object);
```

- target:要销毁的对象

## 路由

由于实体个数可能会很多个,那么需要定义一种实体之间互相通讯的方式

- 角色+id：例如 player(123)，可以发送到 player id 为 123 的实体，例子：{role:"player",id:123}
- 角色名称：全局单例的角色，此时通过名字查找服务，检索出他的地址，然后通讯
- 地址：直接通讯

## 角色：网关

用于连通内外的实体，可以理解为前端实体，它负责以下事情

- 转发客户端：接收客户端的消息，经过一堆过滤器后调用内部实体函数
-

## FrontendSession

表示网关实体接收到客户端调用的上下文。

- 创建：在有连接时创建
- 销毁：链接断开时销毁
- 更新：用于给那些后端实体调用更新，写逻辑
- 获取：每一次消息处理，都可以直接获取到 FrontendSession
- 存放：只存放在网关实体中

## BackendSession

表示后端实体接收到客户端调用的上下文。

- 创建：发起调用时复制 FrontendSession 创建
- 销毁：连接断开时销毁
- 更新：推送给网关，对原始数据进行更新
- 获取：每次被调用，都可以直接获取
- 存放：临时存在

## 修饰器

- Service(name) 定义实体名称等属性
- Handle(name) 类方法修饰器，定义这个函数只能从 gateway 中发过来
- Controller(name)

## 全局事件

> 考虑到事件只是简单的进行发送，性能很高,因此底层只需要一个实体管理即可

- 创建：create(event,options) 可选，用于未来可能的需要用到负载均衡的
- 监听：watch(event,source?) 监听从属于某个 source 的事件，例子：监听
- 触发：trige(event | target,data)

## 带状态的实体

- 创建：内存中创建实体
- 加载：从存储介质中获取数据
- 初始化：通过加载回来的数据进行初始化
- 响应：例如各种 rpc 事件
- 保存：将数据保存到存储介质中
- 销毁：将实体从内存中删除

> 注意：加载和保存都是异步过程，必须要保证好时序。

## 存储
