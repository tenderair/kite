# 大纲

用类似于 nestjs 的思路，去实现一个带状态的多线程游戏框架。不同的是，这个框架用网关+多实体的方案。

## 参考

- [NESTJS 微服务 - Mr_Kahn - 博客园 (cnblogs.com)](https://www.cnblogs.com/Mr-Kahn/p/15129631.html)

## 实体

实体是一个拥有地址，提供业务逻辑的基础单位。可以理解为是其他角色的基类。实体之间可以通过路由发送信息。

- 角色：每个实体都必然有自己的角色，不同角色提供不同的业务逻辑
- 地址：用于实体之间的直接通讯
- 名称：可选
- 线程：每个实体，都会从属于某个线程，在实体创建的时候，通过某个规则调度到线程中去

### 实体：创建

```typescript
function create(
  target: string | object,
  inputs?: Array,
  options?: object
): number;
```

- target: 指代要发送到的对象
  - string：创建一个实体，同时在全局命名服务中注册进去，之后通过名称就可以检索到这个对象的地址
  - object:
    - object.role：角色名称
    - object.id：角色的 id，这个实体，会被分派到这个 id%threads 的线程中
    - object.thread：指定的线程，和 object.id 冲突
    - object.
- inputs: 传递给实体的构造函数的参数
- returns：返回实体地址

### 实体：远程调用

```typescript
function send(
  target: string | object,
  name: string,
  inputs?: Array,
  options?: object
);
function call(
  target: string | object,
  name: string,
  inputs?: Array,
  options?: object
);
```

- target:要发送到的对象
- name: 要远程调用的函数名称
- inputs: 传递给远程调用的参数

### 实体：销毁

```typescript
function destroy(target: string | object);
```

- target:要销毁的对象

## 路由

由于实体个数可能会很多个,那么需要定义一种实体之间互相通讯的方式

- 角色+id：例如 player(123)，可以发送到 player id 为 123 的实体，例子：{role:"player",id:123}
- 角色名称：全局单例的角色，此时通过名字查找服务，检索出他的地址，然后通讯
- 地址：直接通讯

## 角色：网关

用于连通内外的实体，可以理解为前端实体，它负责以下事情

- 转发客户端：接收客户端的消息，经过一堆过滤器后调用内部实体函数
- 

## FrontendSession

表示网关实体接收到客户端调用的上下文。

- 创建：在有连接时创建
- 销毁：链接断开时销毁
- 更新：用于给那些后端实体调用更新，写逻辑
- 获取：每一次消息处理，都可以直接获取到 FrontendSession
- 存放：只存放在网关实体中

## BackendSession

表示后端实体接收到客户端调用的上下文。

- 创建：发起调用时复制 FrontendSession 创建
- 销毁：连接断开时销毁
- 更新：推送给网关，对原始数据进行更新
- 获取：每次被调用，都可以直接获取
- 存放：临时存在
